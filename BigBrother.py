"""
Description:
This Python script uses Selenium to take screenshots of webpages listed in a specified file. It supports input files in both text and Excel formats, containing IP addresses and port numbers. The script operates in headless mode, meaning it does not display a browser UI. It saves the screenshots in a dedicated 'screenshots' directory within the current working directory. Additionally, the script tracks and logs webpages that could not be accessed due to timeouts into a 'timed-out.txt' file.

Usage:
1. Prepare a text (.txt) or Excel (.xlsx) file with IP addresses and port numbers listed (one address per line for text files [ip:port], and in two columns for Excel files [ip | port]).
2. Ensure ChromeDriver is installed and its path is correctly set in the script.
3. Run the script from the command line, specifying the file path and type. For example:
   python BigBrother.py -f /path/to/file -t txt   (for a text file)
   python BigBrother.py -f /path/to/file -t excel (for an Excel file)
4. Check the 'screenshots' directory for the captured screenshots and 'timed-out.txt' for any addresses that timed out.
"""

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException
from concurrent.futures import ThreadPoolExecutor
import argparse
import os
import pandas as pd  

parser = argparse.ArgumentParser(description='Take screenshots of webpages listed in a file.')
parser.add_argument('-f', '--file', required=True, help='Path to the file')
parser.add_argument('-t', '--type', required=True, help='Type of the file (txt or excel)', choices=['txt', 'excel'])
args = parser.parse_args()

print(f"Arguments parsed, file to be processed: {args.file}, file type: {args.type}")


timed_out_addresses = []


screenshots_dir = os.path.join(os.getcwd(), 'screenshots')
os.makedirs(screenshots_dir, exist_ok=True)

def take_screenshot(address):
    print(f"Attempting to take screenshot for: {address}")
    try:
        ip, port = address.split(':')
    except ValueError as e:
        print(f"Failed to split address {address}: {e}")
        return

    options = Options()
    options.add_argument('--headless')
    options.add_argument('--ignore-certificate-errors')
    options.add_argument('--allow-insecure-localhost')
    try:
        driver_path = 'C:/Users/carbanak/Desktop/code/Tools_mine/chromedriver-win64/chromedriver.exe'  # Update this path
        service = Service(executable_path=driver_path)
        driver = webdriver.Chrome(service=service, options=options)
        print("WebDriver initialized successfully.")
    except Exception as e:
        print(f"Failed to initialize WebDriver: {e}")
        return

    url = f"http://{ip}:{port}"
    try:
        print(f"Visiting {url}")
        driver.get(url)
        driver.implicitly_wait(10)
        print(f"Successfully accessed {url}")

        screenshot_filename = os.path.join(screenshots_dir, f'screenshot_{ip}_{port}.png')

        print(f"Saving screenshot to {screenshot_filename}")
        driver.save_screenshot(screenshot_filename)
        print(f"Screenshot saved: {screenshot_filename}")
    except TimeoutException:
        print(f"Timeout occurred for {url}")
        timed_out_addresses.append(address)
    except Exception as e:
        print(f"Failed to take screenshot for {url} - {e}")
    finally:
        driver.quit()

addresses = []
try:
    if args.type == 'txt':
        with open(args.file, 'r') as file:
            addresses = file.read().splitlines()
    elif args.type == 'excel':
        df = pd.read_excel(args.file, usecols=[0, 1], header=None)  # Assumes the first two columns are IP and port
        addresses = df.apply(lambda row: f"{row[0]}:{row[1]}", axis=1).tolist()

    print(f"Loaded addresses from file: {addresses}")
except Exception as e:
    print(f"Failed to read file {args.file}: {e}")

if addresses:
    with ThreadPoolExecutor(max_workers=10) as executor:
        for address in addresses:
            executor.submit(take_screenshot, address)
else:
    print("No valid addresses to process.")

if timed_out_addresses:
    with open('timed-out.txt', 'w') as f:
        for address in timed_out_addresses:
            f.write(f"{address}\n")
    print("Timed out addresses written to timed-out.txt")
